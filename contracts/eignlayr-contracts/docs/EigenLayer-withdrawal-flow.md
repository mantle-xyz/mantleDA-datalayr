
# Withdrawal Flow

Withdrawals from EigenLayer are a multi-step process. This is necessary in order to ensure that funds can only be withdrawn once they are no longer placed 'at stake' on an active task of a service built on top of EigenLayer. For more details on the design of withdrawals and how they guarantee this, see the [Withdrawals Design Doc](./Guaranteed-stake-updates.md).

The first step of any withdrawal involves "queuing" the withdrawal itself. The staker who is withdrawing their assets can specify the InvestmentStrategy(s) they would like to withdraw from, as well as the respective amount of shares and token to withdraw from each of these strategies. Additionally, the staker can specify the address that will ultimately be able to withdraw the funds. Being able to specify an address different from their own allows stakers to "point their withdrawal" to a smart contract, which can potentially facilitate faster/instant withdrawals in the future.

## Queueing a Withdrawal

![Queuing a Withdrawal](images/EL_queuing_a_withdrawal.png?raw=true "Queuing a Withdrawal")

1. The staker starts a queued withdrawal by calling the `InvestmentManager.queueWithdrawal` function.  They set the receiver of the withdrawn funds as `withdrawer` address. Calling `queueWithdrawal` also removes the user's shares in staker-specific storage and the shares delegated to the operator. Shares in the strategies being withdrawn from, however, remain.  This ensures that the value per share reported by each strategy will remain consistent, and that the shares will continue to accrue gains (or losses!) from any strategy management until the withdrawal is completed.
2. Prior to actually performing the above processing, the InvestmentManager calls `Slasher.isFrozen` to ensure that the staker is not 'frozen' in EigenLayer (due to them or the operator they delegate to being slashed).
3. The InvestmentManager calls `EigenLayerDelegation.decreaseDelegatedShares` to account for any necessary decrease in delegated shares (the EigenLayerDelegation contract will not modify its storage if the staker is not an operator and not actively delegated to one).
4. The InvestmentManager queries `EigenLayerDelegation.delegatedTo` to get the account that the caller is *currently delegated to*. A hash of the withdrawal's details – including the account that the caller is currently delegated to – is stored in the InvestmentManager, to record that the queued withdrawal has been created and store details which can be checked against when the withdrawal is completed.
5. If the the staker is withdrawing *all of their shares currently in EigenLayer, and they set the `undelegateIfPossible` input to 'true'*, then with staker will be immediately 'undelegated' from the operator who they are currently delegated to, through the InvestmentManager making a call to `EigenLayerDelegation.undelegate`. This allows the staker to immediately change their delegation to a different operator if desired; in such a case, any *new* deposits by the staker will immediately be delegated to the new operator, while the withdrawn funds will be 'in limbo' until the withdrawal is completed.

## Completing a Queued Withdrawal

![Completing a Queued Withdrawal](images/EL_completing_queued_withdrawal.png?raw=true "Completing a Queued Withdrawal")

1. The withdrawer completes the queued withdrawal after the stake is inactive, by calling `InvestmentManager.completeQueuedWithdrawal`. They specify whether they would like the withdrawal in shares (to be redelegated in the future) or in tokens (to be removed from the EigenLayer platform), through the `withdrawAsTokens` input flag. The withdrawer must also specify an appropriate `middlewareTimesIndex` which proves that the withdrawn funds are no longer at stake on any active task. The appropriate index can be calculated off-chain and checked using the `Slasher.canWithdraw` function. For more details on this design, see the [Withdrawals Design Doc](./Guaranteed-stake-updates.md).
2. The InvestmentManager calls `Slasher.isFrozen` to ensure that the staker who initiated the withdrawal is not 'frozen' in EigenLayer (due to them or the operator they delegate to being slashed). In the event that they are frozen, this indicates that the to-be-withdrawn funds are likely subject to slashing.
3. Depending on the value of the supplied `withdrawAsTokens` input flag:
* If `withdrawAsTokens` is set to 'true', then InvestmentManager calls `InvestmentStrategy.withdraw` on each of the strategies being withdrawn from, causing the withdrawn funds to be transferred from each of the strategies to the withdrawer.
OR
* If `withdrawAsTokens` is set to 'false', then InvestmentManager increases the stored share amounts that the withdrawer has in the strategies in question (effectively completing the transfer of shares from the initiator of the withdrawal to the withdrawer), and then calls `EigenLayerDelegation.increaseDelegatedShares` to trigger any appropriate updates to delegated share amounts.

## Special Case -- Beacon Chain Full Withdrawals

If a withdrawal includes withdrawing 'Beacon Chain ETH' from EigenLayer, then, before *completing* the withdrawal, the staker must trigger a full withdrawal from the Beacon Chain (as of now this must be originated from the validating keys, but details could change as Ethereum finishes implementing Beacon Chain withdrawals) on behalf of enough of their validators to provide sufficient liquidity for their withdrawal.
The staker's EigenPod's balance will eventually increase by the amount withdrawn, and the withdrawals will be reflected in a BeaconChainOracle state root update.
At that point, the staker will prove their full withdrawals (differentiated from partial withdrawals by comparing the amount withdrawn against a hardcoded threshold) credited to the EigenPod against the beacon chain state root via the `verifyBeaconChainFullWithdrawal` function. If the withdrawal's amount is greater than or equal to how much the corresponding Ethereum validator had restaked on EigenLayer, then the excess amount becomes *instantly withdrawable* from the EigenPod through another call to it after the rest of the call to `verifyBeaconChainFullWithdrawal` succeeds. If the withdrawal amount is less than the amount restaked on behalf of the validator in EigenLayer, the EigenPod will assign penalties to its owner equivalent to the amount that was restaked in EigenLayer on behalf of the validator. Finally, before completing the call, the EigenPod will attempt to pay off any penalties its owner owes due to overmmitting its balance to EigenLayer.

Once the above is done, then when the withdrawal is completed through calling `InvestmentManager.completeQueuedWithdrawal` (as above), the InvestmentManager will pass a call to `EigenPodManager.withdrawRestakedBeaconChainETH`, which will in turn pass a call onto the staker's EigenPod itself, invoking the `EigenPod.withdrawRestakedBeaconChainETH` function and triggering the actual transfer of ETH from the EigenPod to the withdrawer. This final call will only fail if the  full withdrawals made and proven to the EigenPod do not provide sufficient liquidity for the EigenLayer withdrawal to occur.
